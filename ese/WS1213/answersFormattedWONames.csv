code;deepComprehension;deepComprElaborate;comprehension;comprElaborate;implementation;implementationElabor;explain;explainElaborate;maintaining;maintainingElaborate;modifying;modifyingElaborate;quality;qualityElaborate;preference;preferenceElaborate;recommendation;recommendationElabor;further
15;1;"In having to do everything step by step, we are forced to look into the details of each component... instead of simply using ""whatever works""....";1;I believe that if we had used the big-bang implementation, chances are that we would not have separated all of the behaviors for each component, we maybe wouldnt even have made components... maybe just one big class called gamma that does everything. So YES, I do think that having done it step by step makes the entire program easier to understand.;1;The stepwise implementation allowed us to test every step of the way. With the big-bang implementation, it would have been much more difficult to test the correct behavior.;3;Well, to explain the big-bang, there would be higher complexity in the code, and perhaps it would not be as organized. However, with explaining the stepwise, we also have to explain the concept of components, and putting them together in boxes, which might add complexity to the explanation.;3;If both where done with primitive boxes, probably the same... but if the big-bang was done without boxes, more likely this would be more difficult.;2;Since in the stepwise approach we know with more detail about each component, I expect it to be easier to make modifications to gamma, because modifications to gamma might mean modifications to the underlying components.;2;It is tested at every step, instead than just at the end.  This provides a much more reliable implementation.;1;For all the reasons above.;1;More organized, and makes us realize how much of the code is actually reused.... which brings up a recurring concept of the class, that we want to find ways to not have to rewrite so much code, and be able to reuse it.;Just that I think it was better than the big-bang idea.
16;1;I don't think I would've understood the final design at all without the stepwise implementation;2;NA;2;NA;1;NA;2;NA;2;NA;3;NA;1;NA;1;NA;NA
17;1;It helped me better understand how easily components could be interchanged and the versatility of using a pipeline structure.;2;NA;2;Helpful that you can go from working version to working version as it gets more complicated;2;NA;3;NA;2;NA;2;NA;3;NA;1;NA;NA
18;1;I felt like there were two parts to completing the design. First was understanding the algorithm.  This was essential for producing the basic HJoin box.  The other part was understanding how the refinement was implementing the same algorithm even if it appeared much more complicated.  I felt that the incremental approach was essential to understanding both parts.;1;I think the stepwise implementation introduces you to the algorithms at the basic block level so that it is much clearer at the refinement level.;2;It might be easier to implement with a big-bang approach, but testing would be much more difficult.  Testing was a challenge for a couple of the blocks in our stepwise implementation, but once we began putting together our refinements, testing was extremely easy.;1;Just like in the class notes, start with the basic algorithm, then expand to each refinement.  Much easier.;1;Not only do we have all of our modular tests, we wrote the code and tests for each box.  It would be much easier to maintain.;2;It might be more challenging to know where to make changes in the stepwise approach, but the ability to make small changes with bigger effects makes it worth it.;2;I'm guessing better. I'm not sure.;1;Much easier to understand as you go. Also puts a lot of the heavy lifting at the beginning of the project rather than at the end.;1;For all the reasons above, yes stepwise is preferred and recommended.;This was a really good project to end the semester on.  Challenging and enjoyable.  
19;3;I don't think it changes anything as far as understanding goes. If you know what each box does, and the overall design, than changing the way you build it doesn't necessarily change your understanding of it.;2;The code should be somewhat the same, but the stepwise should be a little be easier, because everything will be in easy to understand sections where you incrementally built the program.;1;It's so much easier to implement. The big-bang makes it easy to make so many errors, because you can't test each section separately. Stepwise might take a bit longer, but saves you so much time debugging, andis jut a more natural way to build things. You won't get lost in your design trying to do too many things at once.;2;It's easier to explain how each things works individually and then builds on top of that, instead of trying to explain the whole thing at once.;1;Due to the way it was built it should be much easier to maintain. If something breaks or needs to be changed, it's already in sections, and we already have substantial tests. It's easy to add new things, since that's what we were doing the whole time.;1;Same as above. Easier to find things.;2;Well. If you don't get lost in Big-bang, it should be good quality, except you won't have the benefits of the tests, and a more defined layout.;1;It's just more natural, and much easier to think about.;3;Stepwise is just better, unless the program is really small.;N/A
21;2;NA;3;NA;4;NA;1;NA;3;NA;4;NA;3;NA;2;NA;1;NA;NA
22;1;By using a stepwise implementation I am able to understand all the different aspects that a complete algorithm is taking and get a better understanding as a whole. ;2;Looking at a implementation as little parts (smaller implementations) makes it easier to take in the bigger picture. Having less to process at a given time compared to just being shown a huge implementation as a whole makes it substantially easier to understand for me.;2;Smaller programs are usually easier to implement;2;Having already broken up a huge implementation into smaller steps makes explaining an implementation easier because the difficulty of breaking down an explanation is in reality already done for you.;2;A stepwise implementation should be easier to maintain;2;Once again, interchangeable parts.;2;The quality of code done in parts is usually better in quality because it has already been set out to be easier to maintain, modify, and understand.;1;Breaking down a problem has always been my preferred way to tackling a problem because it usually takes away the overwhelming feeling a difficult problem presents. ;1;Make a huge problem easier to solve and understand by breaking it down to smaller and easier problems;NA
23;1;NA;2;NA;2;NA;2;NA;2;NA;2;NA;1;NA;1;NA;1;NA;NA
24;1;Yes, because we had to fully understand and make sure each previous part was working before we could move on. If we had done it our own way, we might've ran into problems/not prepared for those we were unaware of;1;With a big-bang implementation, it would be a very real possibility that the resulting code would be ugly, poorly designed, or confusing. With the stepwise implementation, it was hard to NOT make the code pretty or more understandable.;1;"Since many of the ""core"" pieces (the ReadEnd, Connector, etc) were setup for us already, it was much easier for us to use these parts in conjunction with our own steps to create gamma";1;If I were to attempt to explain the bigbang implementation, I would most likely get lost in the process or get hung up on the wrong details. With the stepwise implementation, I could imagine explaining it piece by piece, making sure they would understand each part before continuing;1;Since it's easier to understand the code (see above), then I would imagine it would be much easier to maintain or update the code, since we would know how it fits in the overall design of the program.;1;We would know where each new part would need to be placed to properly update the code! Not to mention it would be easier to test since everything is more modular, our new code should be more isolated from the other parts.;2;I like to imagine that I could do a big-bang implementation reasonably well, but stepwise was MUCH easier to understand and implement. Whereas this project took me about a week to complete while dealing with 2 other big projects, a big-bang approach would've been considerably more difficult and might have resulted in the coders wasting time on the small parts as opposed to the big picture.;1;See above, but stepwise allowed us to easily implement Gamma in a proper fashion, test it accurately, and prevented us from getting lost in the trees. I clearly understand Gamma now, and I feel that it represented well how to implement big programs stepwise;1;Much easier! Not only in coding, but in understanding as well. Had a great time coding it, and really enjoyed the final design. Even though I'm not a fan of testing (too lazy), doing it in such a modular and iterative fashion was easy and made me confident that bugs that popped up were because of the current step ONLY. Thanks!;Hm, I've said a lot already, but this was a great project and I had a lot of fun working on it. Although we still managed to get some trouble from a few parts, it was much less than we would have with a big-bang approach
25;1;Starting with a general idea of what Gamma does and then improving the design piece-by-piece helped a lot with see how each piece fits together;1;With a big-bang implementation, it's a lot easier to end up hacking and developing messy code that is harder to understand.;2;Easier because it's less likely that bugs would be introduced and missed, leading to many bugs that are hard to find and fix.;2;It's easier to explain each part of Gamma by showing the higher level view of each part first (ie, explaining HJoin with Bloom Filter by first explaining HJoin as a whole);1;It's easier to isolate bugs to a specific box, and adding a new implementation of a primitive would simply mean ripping out the old code and adding in the new code without having to touch any of the code outside of that box.;2;easier because with the pieces broken up the way they are, it's easier to just pull out and plug in changes to boxes or modify the way the boxes are used;1;It's a lot cleaner and you can see step-by-step what was done to build it;1;Forcing me to implement it in a step-wise fashion was helpful in the long run because there was less chance of us make huge mistakes that would take to long to debug.;1;I liked that we were forced to code as cleanly as possible, we didn't have nearly as many of the issues that tends to plague big projects like this that are done in big-bang fashion, like major bugs that are impossible to find and scrambling at the last second to figure out what was wrong with our code.;NA
26;1;A lot of the optimizations towards the end cover up the concepts that were used in the design. The main example is combining the internal SPLITS and MERGES, this destroys some evidence of the application of map reduce on each component.;1;Since the final implementation does not show evidence of all the incremental concepts, it is not immediately obvious why some of the components/associations were designed the way they are.;3;"As long as each component can be tested separately, the big-bang approach is comparable to the stepwise approach when it comes to implementation, at least for a simple design such as gamma. The stepwise approach is more ""agile"" and scalable, but for gamma, it involves more code and more steps, when a big-bang approach would not be significantly harder to debug.";1;The big-bang implementation covers up some of the stepwise concepts used to design gamma. Therefore, explaining the big-bang approach would be much more difficult since explaining the design means explaining the concepts used to create it.;1;The extra code created via the stepwise approach has a pro of making the project modular.;1;The extra code created via the stepwise approach has the pro of making the project modular.;1;Considering that the stepwise implementation is easier to maintain and modify, it is easily higher quality.;3;There are cases where big-bang may be more efficient;1;Stepwise is a great way to learn.;NA
27;1;Knowing how the pieces work allows me know how to connect them. It also enables me to appreciate the optimizations done to get to the final gamma architecture.;1;NA;1;By testing each box and each functionality we can more easily find any bugs and fix them.;2;We'd have to elaborate a lot more on how things worked, whereas, in the big bang implementation we could just say how things worked without going into too much depth.;1;NA;2;NA;2;NA;1;NA;1;NA;NA
28;2;Breaking down the complexity is good not only for implementation, but also for understanding what's going on.;3;"If done correctly, I think the big-bang implementation would be easier to understand, since it wouldn't include pipes and threads. However, its more difficult to ""do it correctly"" therefore it's a tie.";2;Only because in the stepwise approach, thread management became trivial.;2;Again, breaking down the complexity make it easier to implement, understand and, therefore, to explain.;1;It's a lot easier to test independent components.;3;I don't get the question... Gamma is gamma. Modifying it would create a different thing.;1;Since it is easier to debug and maintain, it gives more confidence to the developer that its implementation is right.;1;It takes me less time to remember what's going on every time I start a new programming session. I feel more like I know what I'm doing.;1;As a learning experience, it was very good, but I think that the piping would make it considerably slower for industrial usage.;It would be nice to use a DSL for the glueing of the components and java for the implementation of them.
29;3;I don't really think that this approach improves my understanding of the problem, rather it saves me from hard to find bugs, which means that it decreases the overall development time.;3;Honestly, I don't believe that software engineers ever have a source for understanding a stepwise implementation in real life. If there was such a thing in real life we would lose our jobs, because there is an explanation for a stepwise solution, which even a monkey can implement. Since we had a stepwise implementation in this ideal case, in my opinion neither of the two ways would be better than the other in terms of understanding.;1;I think that stepwise solution is always simpler, since the chunks are as small as my brain can digest them. Compared to a huge code base, where even a small error will take hours to find and maybe a couple of hours more to fix.;4;I think it is harder to explain a complicated system in a stepwise manner if there is no high level understanding of the subject. In this particular system each part by its own is hard to understand because its aim is not seen a separate entity.;3;NA;1;A stepwise implementation always produces lot's of tests, and it is always easier to modify well tested code.;3;It is same if it is tested well, the only difference is in the development process.;3;Depends on how complicated is the system I develop.;1;NA;NA
30;1;NA;2;NA;2;NA;2;NA;1;NA;1;NA;3;NA;2;NA;3;NA;no
31;2;NA;2;NA;2;NA;3;NA;2;NA;2;NA;NA;NA;3;NA;1;NA;NA
32;1;Knowing how each component works separately and being able to construct the final program by connecting those components give us a lor more insight on the design;2;Easier because I feel that it would be more organized since by having a different look at it (in a more structured way) we implemented things separately.;1;I believe it is much easier because you can implement each component individually.;1;I believe that having a step-by-step explanation is always easier to understand than the complete program at once;1;It will probably be more organized;1;Easier to understand and therefore easier to modify. More structured.;1;In my case I believe it is of better quality because I organize things in a better way;1;I prefer having steps to follow and construct programs from individual components that are testable;1;Being able to test each component is invaluable and much easier to debug early on than when the program is complete.;NA
33;1;Seeing each of the pieces in a non-MapReduce form then stepped up to a parallelized form helped immensely.;1;NA;1;NA;1;NA;1;NA;1;NA;1;NA;3;If the project was tiny enough, big-bang.;1;NA;NA
34;2;While I would come around to the same understanding, the incremental process insures you understand when you reach an endpoint.;1;In my experiences any Big Bang Development ends up with many over complications.;1;Like you explain in class, once you finish the small pieces, the rest of the implementation is boilerplate.;2;Depends on who I am explaining it to. The students in the 314 class I am proctoring do not understand anything other than the big-bang approach. However many of my peers found it easier to understand using the step wise explanation.;1;"Having only to update the ""legos"" would make this project much easier to maintain.";1;Same as #5.;1;The final product has much less unnecessary code, or duct tape.;1;I like the ease of doing it in steps. Makes it easier to hold the whole design in your head.;1;I even made my OS group do step-wise implementation on the last 2 projects due to my experience implementing gamma.;NA
35;1;By understanding what the basic functionality of each box was then building upon them to improve their performance, I felt like I completely understood the purpose of each new piece and how the refinements were improving the initial design.;2;I can not imagine that a big-bang implementation would have been easier to understand due to the fact that the resulting code that I wrote was pretty clear. I believe that making a big-bang implementation would have been less more time consuming and not as clean. ;2;I don't know if it would be easier to implement gamma using a big-bang but I'm sure it would be more time consuming and not as well designed. ;1;It was easier to understand the stepwise implementation since I already understood the basic functionality of all the boxes we were refining. ;1;It would be much simpler to maintain smaller pieces of code rather than changing huge chunks. This would also be true given that there are more test cases for each piece of the code.;1;Seems like modification would be easier to do if all you had to do was to change the functionality of one of the primitive boxes or simply create a new one and insert them in the correct location in the code.;1;It is easier to understand small simple pieces of code that I used in a my stepwise implementation than it is to read large pieces of code that are sure to have been used if I made a big bang implementation. ;1;Stepwise implementation allows you to break the project up into smaller parts which allows for faster development when working with a group. ;1;It forces you to fully grasp what it going on before you can actually write up any code.;I have learned the most from this project than any other CS project I have ever done. It starts of by implementing the simple hjoin functionality then building upon it piece by piece. It showed how design can make code clearer and easier to understand as well as make it easier to add functionality. It also shows how test you have already written will help you find bugs as you change the design of your code.
36;2;I think you're more likely to end up with a CORRECT implementation, which is a prerequisite to understanding the implementation in my view.;1;When all the parts are clearly labeled, it's easier to understand.  The fact that only the class used changed in some of our test cases shows how simple it is to see what's going on.;1;I always have a harder time if presented with something I have to break down to understand its parts as compared to something where the parts are given and you use a process to put it together.  (I'd rather see a bottom-up schematic than top-down, assuming it's the same information in the end.;1;Just like you can prove the whole correct if you can prove the start and every transformation, you can understand the whole if you understand the parts then link them together as prescribed.;1;Always easier to find bugs if the code is well divided, and implementations of primitives is simply a matter of swapping classes, as we saw.;1;Whether you mean modify how it's put together or modify the particular implementation, both would be easier with a stepwise approach.;2;Better because of the things discussed above--easier to maintain, easier to change.  Might not be *inherently* better as far as correctness, and might even be worse when it comes to optimization.;1;I've almost always dealt with big-bang approaches because that's what I have to work with, but I found it easy and even enjoyable to do this project because of the stepwise nature of it.;1;"For all the reasons given above, but with two caveats: one, as mentioned in #7, it might not lead to the best optimization.  Two, I think you're likely to encounter more big-bang approaches than stepwise in industry (and maybe in research as well, you'd know better than I would) so you might get lulled into a false sense of security from being on ""easy mode"".";Like I said, I had fun with it.  This was my favorite project, with P7 coming in second.  I feel like I understand Gamma way better than I do a lot of the other projects.
37;2;By stepping through the individual components that make up gamma, one gets to learn each component in itself. This in turn leads one to understand why gamma is formed the way it is, something that is harder to come by if coding it another way.;1;By being able to view the individual components that form gamma, the purpose gamma serves is clarified and the formation of the gamma as a whole is understood.;2;If the purpose of writing the code is to display easy to read and easy to manage code, then implementing gamma with he step method is much easier.;1;The steps in themselves describe the acts of gamma, while one must go out of their way to explicitly explain what is going on with a big bang method gamma.;1;With the separation of concerns that the step method gives, changes and debugging is exceedingly easy compared to the cluster that is the big bang method.;1;All that changes to gamma consist of within the step method implication is just changing the ordering of the steps, which is exceedingly easy and is not that error prone. While in contrast, changing the function around in the big bang method takes time and is prone to errors.;2;It is better in the sense that it is much more manageable than using the big bang method, though the big bang method could be optimized to be more efficient than the step method.;1;The individual step method gives a better understanding of gamma than doing it with the big bang method for me, also its quite easy to implement and debug with the step method.;1;The step wise manner is a much easier to understand implementation and is quite way to debug if problems arise. ;The begging process can be done just as efficiently without the use of the sink and doNothing components.
38;1;Because I programmed gamma in a stepwise implementation, I was able to understand each component individually. I think this better helps to keep the abstractions straight in my head, and really understand what work is being performed how and where.;1;It is always easier for me to understand source code in small sized chunks. The stepwise implementation provides better separation of concerns and divides the source code between the internal modules making it faster to read and understand.;3;Depends on your level of understanding of Gamma. For someone with little understanding stepwise is easier.;4;more steps to explain, higher abstraction is better for explanation ;2;step wise is modular and you can swap out internal components, big band approach would make this difficult.;2;when you use stepwise and modify gamma it is easier to see where something goes wrong if you have the granular unit tests involved with the stepwise approach;2;better quality, easier to read, understand, and maintain.;1;all around better approach in my opinion;1;all around better approach in my opinion;none, fun project, learned a lot
39;3;NA;NA;NA;NA;NA;3;NA;3;NA;3;NA;3;NA;3;NA;3;NA;NA
40;1;NA;1;Would have been overwhelming without the steps explicitly laid out;2;NA;2;NA;2;Because of better overall understanding of each step;2;Understanding each step makes it easier to determine where modifications need to be made.;2;I think a big bang implementation would have been very difficult to debug, resulting in hacks ;1;Stepwise implementation is very clear and gives an easily understandable view of what changes we have to make;1;Big bang would be overwhelming.;Made implementation very straightforward and allowed us to really understand what we were doing
41;2;I think the structure of gamma was pretty easy to grasp, so I got the overall picture pretty easily. However, doing it step by step helped me to understand the individual boxes much better.;4;Similarly, understanding was slightly easier doing it stepwise. This is more based on forming an understanding of threads, however. ;5;All that being said, gamma would be much easier to write all at once in my opinion. It's fewer tests, especially acceptance tests, but the same number of unit tests. You could write out all the boxes, and assuming your tests all work correctly, feel confident the final product worked.;1;The slides proved that having gamma explained stepwise was much easier to understand. I wouldn't have gotten it without the extra help the stepwise implementation the slides showed.;3;Since we made each box separately, I don't think updating either one would be difficult. There certainly doesn't appear to be any difference in updating the two styles.;4;There are more parts interconnected using the stepbystep approach, so modifying the underlying structure would deal with more interactions. ;2;I'd say its better, mainly because we were forced to write each box independently. It means we couldn't create a box that did everything.;3;It depends how well I understand the final solution. In the vase of gamma, since I understood the final solution from the slides, I would've liked to jump straight to the final product. But for problems I have little grasp on, stepwise would be preferable.;1;Since this is a class, I think stepwise is better to gain a better understanding.;Nope.
42;1;I think it's important to try both and then ultimately attempt the stepwise implementation. You have to fail to appreciate.;1;NA;1;There are a lot of pitfalls to avoid in the bigbang approach. Further, if something ever changed, client's requirements or so fourth, then one's bigbang implementation may not be robust enough to accommodate those changes.;1;parts are separated into logically consistent compartments, thus making it easier to explain.;1;See bottom of my response on #3.;1;NA;2;I never did a big bang implementation (that would be hard) but I feel like I can accurately say that the stepwise is better.;1;NA;1;OMG if someone attempted to do this in one step I would give them 40 lashes.;NA
44;1;Because each step is explained I understand everything about the implementation and there are no mystery steps.;1;I prefer undertanding every step and letter on reducing the design;1;I feel that if I don't understand every step I may make a mistake not easy to track;3;Since they are the same ultimately the produce the same result and it is about as wasy to explain;1;Since it is a simplified verzion of the stepwise but produces the same result it is easier to maintain.;1;As long as any of the steps in the stepwise approach does not need modification, it is easier to modify the more simple big-bang approach.;3;That is because both produce the same result;1;I would say stepwise until it becomes second nature to me how to derive a big-bang version directly.;1;Because it is kess likely to make mistakes and easier to see what the are doing.;I think is is a very nice approach to train ourselves how to derive the big-bang version.
;;;;;;;;;;;;;;;;;;;
;;Meaning of scale (range from 1 to 5);;;;;;;;;;;;;;;;;
deepCompr;Do you think a structured way that a stepwise implementation imposes gives you <b>a deeper understanding of Gamma's design</b> than you would get by not using it and doing it your own way?;1: much deeper;5: much worse;;;;;;;;;;;;;;;;
comprehension;Do you think it would be easier or more <b>difficult to understand a stepwise implementation (i.e., your resulting code)</b> compared to a big-bang implementation?;1: considerably easier;5: considerably more difficult;;;;;;;;;;;;;;;;
implementation;Do you think it would be easier or more difficult <b>to implement</b> Gamma with a stepwise approach compared to a big-bang approach?;1: considerably easier;5: considerably more difficult;;;;;;;;;;;;;;;;
explain;Do you think it would be easier or more difficult <b>to explain</b> a stepwise implementation of Gamma compared to a big-bang implementation?;1: considerably easier;5: considerably more difficult;;;;;;;;;;;;;;;;
maintaining;Do you think it would be easier or more difficult <b>to maintain </b>(e.g. add new implementations of primitive boxes or find bugs) Gamma implemented with a stepwise approach compared to a big-bang approach?;1: considerably easier;5: considerably more difficult;;;;;;;;;;;;;;;;
modifying;Do you think it would be easier or more difficult to <b>modify</b> Gamma with a stepwise approach compared to a big-bang approach?;1: considerably easier;5: considerably more difficult;;;;;;;;;;;;;;;;
quality;Is a stepwise implementation (i.e., your resulting code) of better or worse <b>quality</b> than a big-bang implementation?;1: considerably better;5: considerably worse;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;
recommendation;Would you <b>recommend your fellow students</b> implementing Gamma in a stepwise manner or in a big-bang manner?;1: stepwise;2: big bang;3: depends;;;;;;;;;;;;;;;
preference;Do you <b>prefer</b> using a stepwise implementation or a big-bang implementation?;1: stepwise;2: big bang;3: depends;;;;;;;;;;;;;;;
